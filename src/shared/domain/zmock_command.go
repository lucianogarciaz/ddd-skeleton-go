// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package domain

import (
	"sync"
)

// Ensure, that CommandMock does implement Command.
// If this is not the case, regenerate this file with moq.
var _ Command = &CommandMock{}

// CommandMock is a mock implementation of Command.
//
//     func TestSomethingThatUsesCommand(t *testing.T) {
//
//         // make and configure a mocked Command
//         mockedCommand := &CommandMock{
//             NameFunc: func() string {
// 	               panic("mock out the Name method")
//             },
//         }
//
//         // use mockedCommand in code that requires Command
//         // and then make assertions.
//
//     }
type CommandMock struct {
	// NameFunc mocks the Name method.
	NameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Name holds details about calls to the Name method.
		Name []struct {
		}
	}
	lockName sync.RWMutex
}

// Name calls NameFunc.
func (mock *CommandMock) Name() string {
	if mock.NameFunc == nil {
		panic("CommandMock.NameFunc: method is nil but Command.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//     len(mockedCommand.NameCalls())
func (mock *CommandMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Ensure, that CommandBusMock does implement CommandBus.
// If this is not the case, regenerate this file with moq.
var _ CommandBus = &CommandBusMock{}

// CommandBusMock is a mock implementation of CommandBus.
//
//     func TestSomethingThatUsesCommandBus(t *testing.T) {
//
//         // make and configure a mocked CommandBus
//         mockedCommandBus := &CommandBusMock{
//             DispatchFunc: func(in1 Command) error {
// 	               panic("mock out the Dispatch method")
//             },
//             RegisterHandlerFunc: func(in1 Command, in2 CommandHandler) error {
// 	               panic("mock out the RegisterHandler method")
//             },
//         }
//
//         // use mockedCommandBus in code that requires CommandBus
//         // and then make assertions.
//
//     }
type CommandBusMock struct {
	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(in1 Command) error

	// RegisterHandlerFunc mocks the RegisterHandler method.
	RegisterHandlerFunc func(in1 Command, in2 CommandHandler) error

	// calls tracks calls to the methods.
	calls struct {
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// In1 is the in1 argument value.
			In1 Command
		}
		// RegisterHandler holds details about calls to the RegisterHandler method.
		RegisterHandler []struct {
			// In1 is the in1 argument value.
			In1 Command
			// In2 is the in2 argument value.
			In2 CommandHandler
		}
	}
	lockDispatch        sync.RWMutex
	lockRegisterHandler sync.RWMutex
}

// Dispatch calls DispatchFunc.
func (mock *CommandBusMock) Dispatch(in1 Command) error {
	if mock.DispatchFunc == nil {
		panic("CommandBusMock.DispatchFunc: method is nil but CommandBus.Dispatch was just called")
	}
	callInfo := struct {
		In1 Command
	}{
		In1: in1,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(in1)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//     len(mockedCommandBus.DispatchCalls())
func (mock *CommandBusMock) DispatchCalls() []struct {
	In1 Command
} {
	var calls []struct {
		In1 Command
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// RegisterHandler calls RegisterHandlerFunc.
func (mock *CommandBusMock) RegisterHandler(in1 Command, in2 CommandHandler) error {
	if mock.RegisterHandlerFunc == nil {
		panic("CommandBusMock.RegisterHandlerFunc: method is nil but CommandBus.RegisterHandler was just called")
	}
	callInfo := struct {
		In1 Command
		In2 CommandHandler
	}{
		In1: in1,
		In2: in2,
	}
	mock.lockRegisterHandler.Lock()
	mock.calls.RegisterHandler = append(mock.calls.RegisterHandler, callInfo)
	mock.lockRegisterHandler.Unlock()
	return mock.RegisterHandlerFunc(in1, in2)
}

// RegisterHandlerCalls gets all the calls that were made to RegisterHandler.
// Check the length with:
//     len(mockedCommandBus.RegisterHandlerCalls())
func (mock *CommandBusMock) RegisterHandlerCalls() []struct {
	In1 Command
	In2 CommandHandler
} {
	var calls []struct {
		In1 Command
		In2 CommandHandler
	}
	mock.lockRegisterHandler.RLock()
	calls = mock.calls.RegisterHandler
	mock.lockRegisterHandler.RUnlock()
	return calls
}

// Ensure, that CommandHandlerMock does implement CommandHandler.
// If this is not the case, regenerate this file with moq.
var _ CommandHandler = &CommandHandlerMock{}

// CommandHandlerMock is a mock implementation of CommandHandler.
//
//     func TestSomethingThatUsesCommandHandler(t *testing.T) {
//
//         // make and configure a mocked CommandHandler
//         mockedCommandHandler := &CommandHandlerMock{
//             HandleFunc: func(in1 Command) error {
// 	               panic("mock out the Handle method")
//             },
//         }
//
//         // use mockedCommandHandler in code that requires CommandHandler
//         // and then make assertions.
//
//     }
type CommandHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(in1 Command) error

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// In1 is the in1 argument value.
			In1 Command
		}
	}
	lockHandle sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *CommandHandlerMock) Handle(in1 Command) error {
	if mock.HandleFunc == nil {
		panic("CommandHandlerMock.HandleFunc: method is nil but CommandHandler.Handle was just called")
	}
	callInfo := struct {
		In1 Command
	}{
		In1: in1,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	return mock.HandleFunc(in1)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//     len(mockedCommandHandler.HandleCalls())
func (mock *CommandHandlerMock) HandleCalls() []struct {
	In1 Command
} {
	var calls []struct {
		In1 Command
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}
