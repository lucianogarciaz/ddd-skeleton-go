// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package event

import (
	"sync"
)

// Ensure, that DomainEventSubscriberMock does implement DomainEventSubscriber.
// If this is not the case, regenerate this file with moq.
var _ DomainEventSubscriber = &DomainEventSubscriberMock{}

// DomainEventSubscriberMock is a mock implementation of DomainEventSubscriber.
//
//     func TestSomethingThatUsesDomainEventSubscriber(t *testing.T) {
//
//         // make and configure a mocked DomainEventSubscriber
//         mockedDomainEventSubscriber := &DomainEventSubscriberMock{
//             HandleFunc: func(in1 DomainEvent) error {
// 	               panic("mock out the Handle method")
//             },
//             SubscribedToFunc: func() []DomainEvent {
// 	               panic("mock out the SubscribedTo method")
//             },
//         }
//
//         // use mockedDomainEventSubscriber in code that requires DomainEventSubscriber
//         // and then make assertions.
//
//     }
type DomainEventSubscriberMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(in1 DomainEvent) error

	// SubscribedToFunc mocks the SubscribedTo method.
	SubscribedToFunc func() []DomainEvent

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// In1 is the in1 argument value.
			In1 DomainEvent
		}
		// SubscribedTo holds details about calls to the SubscribedTo method.
		SubscribedTo []struct {
		}
	}
	lockHandle       sync.RWMutex
	lockSubscribedTo sync.RWMutex
}

// Handle calls HandleFunc.
func (mock *DomainEventSubscriberMock) Handle(in1 DomainEvent) error {
	if mock.HandleFunc == nil {
		panic("DomainEventSubscriberMock.HandleFunc: method is nil but DomainEventSubscriber.Handle was just called")
	}
	callInfo := struct {
		In1 DomainEvent
	}{
		In1: in1,
	}
	mock.lockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	mock.lockHandle.Unlock()
	return mock.HandleFunc(in1)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//     len(mockedDomainEventSubscriber.HandleCalls())
func (mock *DomainEventSubscriberMock) HandleCalls() []struct {
	In1 DomainEvent
} {
	var calls []struct {
		In1 DomainEvent
	}
	mock.lockHandle.RLock()
	calls = mock.calls.Handle
	mock.lockHandle.RUnlock()
	return calls
}

// SubscribedTo calls SubscribedToFunc.
func (mock *DomainEventSubscriberMock) SubscribedTo() []DomainEvent {
	if mock.SubscribedToFunc == nil {
		panic("DomainEventSubscriberMock.SubscribedToFunc: method is nil but DomainEventSubscriber.SubscribedTo was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSubscribedTo.Lock()
	mock.calls.SubscribedTo = append(mock.calls.SubscribedTo, callInfo)
	mock.lockSubscribedTo.Unlock()
	return mock.SubscribedToFunc()
}

// SubscribedToCalls gets all the calls that were made to SubscribedTo.
// Check the length with:
//     len(mockedDomainEventSubscriber.SubscribedToCalls())
func (mock *DomainEventSubscriberMock) SubscribedToCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSubscribedTo.RLock()
	calls = mock.calls.SubscribedTo
	mock.lockSubscribedTo.RUnlock()
	return calls
}

// Ensure, that EventBusMock does implement EventBus.
// If this is not the case, regenerate this file with moq.
var _ EventBus = &EventBusMock{}

// EventBusMock is a mock implementation of EventBus.
//
//     func TestSomethingThatUsesEventBus(t *testing.T) {
//
//         // make and configure a mocked EventBus
//         mockedEventBus := &EventBusMock{
//             PublishFunc: func(events ...DomainEvent) error {
// 	               panic("mock out the Publish method")
//             },
//         }
//
//         // use mockedEventBus in code that requires EventBus
//         // and then make assertions.
//
//     }
type EventBusMock struct {
	// PublishFunc mocks the Publish method.
	PublishFunc func(events ...DomainEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Events is the events argument value.
			Events []DomainEvent
		}
	}
	lockPublish sync.RWMutex
}

// Publish calls PublishFunc.
func (mock *EventBusMock) Publish(events ...DomainEvent) error {
	if mock.PublishFunc == nil {
		panic("EventBusMock.PublishFunc: method is nil but EventBus.Publish was just called")
	}
	callInfo := struct {
		Events []DomainEvent
	}{
		Events: events,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(events...)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedEventBus.PublishCalls())
func (mock *EventBusMock) PublishCalls() []struct {
	Events []DomainEvent
} {
	var calls []struct {
		Events []DomainEvent
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Ensure, that DomainEventMock does implement DomainEvent.
// If this is not the case, regenerate this file with moq.
var _ DomainEvent = &DomainEventMock{}

// DomainEventMock is a mock implementation of DomainEvent.
//
//     func TestSomethingThatUsesDomainEvent(t *testing.T) {
//
//         // make and configure a mocked DomainEvent
//         mockedDomainEvent := &DomainEventMock{
//             AggregateIDFunc: func() string {
// 	               panic("mock out the AggregateID method")
//             },
//             EventIDFunc: func() *string {
// 	               panic("mock out the EventID method")
//             },
//             EventNameFunc: func() string {
// 	               panic("mock out the EventName method")
//             },
//             FromPrimitivesFunc: func(aggregateID string, body map[string]interface{}, eventID string, occurredOn string) (DomainEvent, error) {
// 	               panic("mock out the FromPrimitives method")
//             },
//             OcurredOnFunc: func() *string {
// 	               panic("mock out the OcurredOn method")
//             },
//             ToPrimitivesFunc: func() (map[string]interface{}, error) {
// 	               panic("mock out the ToPrimitives method")
//             },
//         }
//
//         // use mockedDomainEvent in code that requires DomainEvent
//         // and then make assertions.
//
//     }
type DomainEventMock struct {
	// AggregateIDFunc mocks the AggregateID method.
	AggregateIDFunc func() string

	// EventIDFunc mocks the EventID method.
	EventIDFunc func() *string

	// EventNameFunc mocks the EventName method.
	EventNameFunc func() string

	// FromPrimitivesFunc mocks the FromPrimitives method.
	FromPrimitivesFunc func(aggregateID string, body map[string]interface{}, eventID string, occurredOn string) (DomainEvent, error)

	// OcurredOnFunc mocks the OcurredOn method.
	OcurredOnFunc func() *string

	// ToPrimitivesFunc mocks the ToPrimitives method.
	ToPrimitivesFunc func() (map[string]interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// AggregateID holds details about calls to the AggregateID method.
		AggregateID []struct {
		}
		// EventID holds details about calls to the EventID method.
		EventID []struct {
		}
		// EventName holds details about calls to the EventName method.
		EventName []struct {
		}
		// FromPrimitives holds details about calls to the FromPrimitives method.
		FromPrimitives []struct {
			// AggregateID is the aggregateID argument value.
			AggregateID string
			// Body is the body argument value.
			Body map[string]interface{}
			// EventID is the eventID argument value.
			EventID string
			// OccurredOn is the occurredOn argument value.
			OccurredOn string
		}
		// OcurredOn holds details about calls to the OcurredOn method.
		OcurredOn []struct {
		}
		// ToPrimitives holds details about calls to the ToPrimitives method.
		ToPrimitives []struct {
		}
	}
	lockAggregateID    sync.RWMutex
	lockEventID        sync.RWMutex
	lockEventName      sync.RWMutex
	lockFromPrimitives sync.RWMutex
	lockOcurredOn      sync.RWMutex
	lockToPrimitives   sync.RWMutex
}

// AggregateID calls AggregateIDFunc.
func (mock *DomainEventMock) AggregateID() string {
	if mock.AggregateIDFunc == nil {
		panic("DomainEventMock.AggregateIDFunc: method is nil but DomainEvent.AggregateID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAggregateID.Lock()
	mock.calls.AggregateID = append(mock.calls.AggregateID, callInfo)
	mock.lockAggregateID.Unlock()
	return mock.AggregateIDFunc()
}

// AggregateIDCalls gets all the calls that were made to AggregateID.
// Check the length with:
//     len(mockedDomainEvent.AggregateIDCalls())
func (mock *DomainEventMock) AggregateIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAggregateID.RLock()
	calls = mock.calls.AggregateID
	mock.lockAggregateID.RUnlock()
	return calls
}

// EventID calls EventIDFunc.
func (mock *DomainEventMock) EventID() *string {
	if mock.EventIDFunc == nil {
		panic("DomainEventMock.EventIDFunc: method is nil but DomainEvent.EventID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEventID.Lock()
	mock.calls.EventID = append(mock.calls.EventID, callInfo)
	mock.lockEventID.Unlock()
	return mock.EventIDFunc()
}

// EventIDCalls gets all the calls that were made to EventID.
// Check the length with:
//     len(mockedDomainEvent.EventIDCalls())
func (mock *DomainEventMock) EventIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEventID.RLock()
	calls = mock.calls.EventID
	mock.lockEventID.RUnlock()
	return calls
}

// EventName calls EventNameFunc.
func (mock *DomainEventMock) EventName() string {
	if mock.EventNameFunc == nil {
		panic("DomainEventMock.EventNameFunc: method is nil but DomainEvent.EventName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEventName.Lock()
	mock.calls.EventName = append(mock.calls.EventName, callInfo)
	mock.lockEventName.Unlock()
	return mock.EventNameFunc()
}

// EventNameCalls gets all the calls that were made to EventName.
// Check the length with:
//     len(mockedDomainEvent.EventNameCalls())
func (mock *DomainEventMock) EventNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEventName.RLock()
	calls = mock.calls.EventName
	mock.lockEventName.RUnlock()
	return calls
}

// FromPrimitives calls FromPrimitivesFunc.
func (mock *DomainEventMock) FromPrimitives(aggregateID string, body map[string]interface{}, eventID string, occurredOn string) (DomainEvent, error) {
	if mock.FromPrimitivesFunc == nil {
		panic("DomainEventMock.FromPrimitivesFunc: method is nil but DomainEvent.FromPrimitives was just called")
	}
	callInfo := struct {
		AggregateID string
		Body        map[string]interface{}
		EventID     string
		OccurredOn  string
	}{
		AggregateID: aggregateID,
		Body:        body,
		EventID:     eventID,
		OccurredOn:  occurredOn,
	}
	mock.lockFromPrimitives.Lock()
	mock.calls.FromPrimitives = append(mock.calls.FromPrimitives, callInfo)
	mock.lockFromPrimitives.Unlock()
	return mock.FromPrimitivesFunc(aggregateID, body, eventID, occurredOn)
}

// FromPrimitivesCalls gets all the calls that were made to FromPrimitives.
// Check the length with:
//     len(mockedDomainEvent.FromPrimitivesCalls())
func (mock *DomainEventMock) FromPrimitivesCalls() []struct {
	AggregateID string
	Body        map[string]interface{}
	EventID     string
	OccurredOn  string
} {
	var calls []struct {
		AggregateID string
		Body        map[string]interface{}
		EventID     string
		OccurredOn  string
	}
	mock.lockFromPrimitives.RLock()
	calls = mock.calls.FromPrimitives
	mock.lockFromPrimitives.RUnlock()
	return calls
}

// OcurredOn calls OcurredOnFunc.
func (mock *DomainEventMock) OcurredOn() *string {
	if mock.OcurredOnFunc == nil {
		panic("DomainEventMock.OcurredOnFunc: method is nil but DomainEvent.OcurredOn was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOcurredOn.Lock()
	mock.calls.OcurredOn = append(mock.calls.OcurredOn, callInfo)
	mock.lockOcurredOn.Unlock()
	return mock.OcurredOnFunc()
}

// OcurredOnCalls gets all the calls that were made to OcurredOn.
// Check the length with:
//     len(mockedDomainEvent.OcurredOnCalls())
func (mock *DomainEventMock) OcurredOnCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOcurredOn.RLock()
	calls = mock.calls.OcurredOn
	mock.lockOcurredOn.RUnlock()
	return calls
}

// ToPrimitives calls ToPrimitivesFunc.
func (mock *DomainEventMock) ToPrimitives() (map[string]interface{}, error) {
	if mock.ToPrimitivesFunc == nil {
		panic("DomainEventMock.ToPrimitivesFunc: method is nil but DomainEvent.ToPrimitives was just called")
	}
	callInfo := struct {
	}{}
	mock.lockToPrimitives.Lock()
	mock.calls.ToPrimitives = append(mock.calls.ToPrimitives, callInfo)
	mock.lockToPrimitives.Unlock()
	return mock.ToPrimitivesFunc()
}

// ToPrimitivesCalls gets all the calls that were made to ToPrimitives.
// Check the length with:
//     len(mockedDomainEvent.ToPrimitivesCalls())
func (mock *DomainEventMock) ToPrimitivesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockToPrimitives.RLock()
	calls = mock.calls.ToPrimitives
	mock.lockToPrimitives.RUnlock()
	return calls
}
